It is always good practice to add test cases for existing functions. Running these tests will help to check if anything broken during code update.

First add a new file **pytest.ini** in repo root folder:

```
[pytest]
pythonpath = backend

markers =
    e2e: end-to-end tests that require the app running
    fastapi: tests for FastAPI APIs
```

It shows we'll organize our test case into two categories: "fastapi" is for testing API handling by backend. "e2e" is testing frontend by simulating user interaction with web page.

Update **backend/app/config/config.py**. We'll create a fake user which is used to testing database adding record:

```
TEST_PING = "pong!"
LOCAL_HOST_URL = "http://localhost:5173"

from pydantic import BaseModel, Field
from typing import Dict

class UserAddResultType(BaseModel):
    status_code: int = Field(..., description="HTTP status code for the result")
    message: str = Field(..., description="Description message for the result")

USER_ADD_RESULT: Dict[str, UserAddResultType] = {
    "success": UserAddResultType(status_code=200, message="User added successfully"),
    "duplicate": UserAddResultType(status_code=401, message="User already exsited"),
    "error": UserAddResultType(status_code=501, message="Database error"),
}

USER_DELETE_RESULT: Dict[str, UserAddResultType] = {
    "success": UserAddResultType(status_code=200, message="User deleted successfully"),
    "not_found": UserAddResultType(status_code=401, message="User not found"),
    "error": UserAddResultType(status_code=501, message="Database error"),
}

FakeUser = {
    "name": "BADBEFF_USER_123",
    "gender": "Male",
    "age": 20
}
```

Update **backend/app/users/userdb_ops.py** to support delete user, since we'll delete the fake user after test finishes:

```
from typing import Dict, Any, Optional
from sqlalchemy.orm import Session
from sqlalchemy import func
from .models import Users
from app.config.config import UserAddResultType, USER_ADD_RESULT, USER_DELETE_RESULT, FakeUser


def choose_ramdon_user(db: Session) -> Optional[Dict[str, Any]]:
    """
    Randomly select a user from the users table.
    Returns None if no users exist in the database.
    """
    # Get total count of users
    try:
        total_users = db.query(Users).count()
    except Exception as e:
        print(f"⚠️ Error getting total users: {e}")
        return None
    
    if total_users == 0:
        return None
    
    # Get a random user using OFFSET with random ordering
    random_user = db.query(Users).order_by(func.random()).first()
    
    if random_user:
        return {
            "name": random_user.name,
            "gender": random_user.gender,
            "age": random_user.age,
        }
    
    return None


def add_user(db: Session, user: Dict[str, Any]) -> UserAddResultType:
    """
    Add a user to the users table.
    Checks for duplicate user and returns result accordingly.
    """
    # Check if user already exists (by name only)
    try:
        existing_user = db.query(Users).filter_by(
            name=user["name"]
        ).first()
    except Exception as e:
        db.rollback()
        return USER_ADD_RESULT["error"]
    if existing_user:
        return USER_ADD_RESULT["duplicate"]

    try:
        db.add(Users(name=user["name"], gender=user["gender"], age=user["age"]))
        db.commit()
        return USER_ADD_RESULT["success"]
    except Exception as e:
        db.rollback()
        return USER_ADD_RESULT["error"]
    return


def delete_user(db: Session, user: Dict[str, str]) -> UserAddResultType:
    """
    Delete a user from the users table.
    """
    user_name = user["name"]
    #check if user does not exist:
    if not db.query(Users).filter_by(name=user_name).first():
        return USER_DELETE_RESULT["not_found"]

    try:
        db.query(Users).filter_by(name=user_name).delete()
        db.commit()
        return USER_DELETE_RESULT["success"]
    except Exception as e:
        db.rollback()
        return USER_DELETE_RESULT["error"]
    return


def delete_fake_user(db: Session) -> UserAddResultType:
    """
    Delete the fake test user from the users table.
    This function is specifically for cleaning up test data.
    """
    return delete_user(db, {"name": FakeUser["name"]})
```

Also update **backend/app/users/userdb_requests.py** for supporing deleting user:

```
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session
from .userdb_ops import choose_ramdon_user, add_user, delete_user


router = APIRouter()


def get_db(request: Request) -> Session:
    """Dependency to get database session"""
    return request.app.state.db_session_factory()


@router.post("/addUser")
async def add_user_request(request: Request, db: Session = Depends(get_db)):
    # get the user from the request:
    user = await request.json()
    ret = add_user(db, user)
    return ret


@router.get("/randomUser")
async def ramdon_user(db: Session = Depends(get_db)) -> dict:
    user = choose_ramdon_user(db)
    if user is None:
        raise HTTPException(status_code=404, detail="No users found in database")
    return user


@router.post("/deleteUser")
async def delete_user_request(request: Request, db: Session = Depends(get_db)):
    # get the user from the request:
    user = await request.json()
    ret = delete_user(db, user)
    return ret
```

Now we can add test cases. First add **backend/tests/test_fastapi.py**. We'll test if API call for randomUser and addUser are handled correctly:

```
import pytest
from fastapi.testclient import TestClient

from app.main import app
from app.users.userdb_utils import init_database_session, seed_database
from app.config.config import TEST_PING
from app.config.config import USER_ADD_RESULT, USER_DELETE_RESULT, FakeUser


@pytest.fixture(scope="module")
def setup_database():
    """Set up database session for all FastAPI tests."""
    # Initialize database session for testing
    init_database_session(app)
    seed_database()
    
    # Provide database session to tests (assumes tables and data already exist)
    SessionLocal = app.state.db_session_factory
    db = SessionLocal()
    try:
        yield db  # Provide the database session to tests
        
    finally:
        db.close()
        # Clean up database engine
        if hasattr(app.state, 'db_engine'):
            app.state.db_engine.dispose()


@pytest.mark.fastapi
def test_ping_returns_test_ping_string():
    client = TestClient(app)
    response = client.get("/ping")
    assert response.status_code == 200
    body = response.json()
    assert body.get("message") == TEST_PING


@pytest.mark.fastapi
def test_ramdon_user_returns_valid_user(setup_database):
    """Test that /randomUser endpoint returns a valid user when users exist in database."""
    # Test the endpoint
    client = TestClient(app)
    response = client.get("/randomUser")
    
    # Verify response
    assert response.status_code == 200
    body = response.json()
    
    # Verify the response contains the expected fields
    assert "name" in body
    assert "gender" in body
    assert "age" in body
    
    # Verify data types
    assert isinstance(body["name"], str)
    assert isinstance(body["gender"], str)
    assert isinstance(body["age"], int)
    
    # Verify gender is one of the valid values
    assert body["gender"] in ["Male", "Female"]
    
    # Verify age is within valid range
    assert 0 <= body["age"] <= 100
    
    # Verify name is not empty
    assert len(body["name"]) > 0

@pytest.mark.fastapi
def test_add_and_delete_user():
    """Test that /addUser and /deleteUser endpoints work correctly."""

    client = TestClient(app)
    response = client.post("/addUser", json=FakeUser)
    assert response.status_code == USER_ADD_RESULT["success"].status_code
    body = response.json()
    assert body.get("message") == USER_ADD_RESULT["success"].message

    response = client.post("/deleteUser", json={"name": FakeUser["name"]})
    assert response.status_code == USER_DELETE_RESULT["success"].status_code
    body = response.json()
    assert body.get("message") == USER_DELETE_RESULT["success"].message
```

For frontend, add file **backend/tests/test_webpage.py**. It uses Playwright to simulate user interaction with web page and check the result:

```
import pytest
from playwright.sync_api import Page, expect
from sqlalchemy.orm import Session

from app.config.config import TEST_PING, FakeUser, USER_ADD_RESULT, LOCAL_HOST_URL
from app.users.userdb_ops import delete_fake_user
from app.users.userdb_utils import init_database_session
from app.main import app


@pytest.fixture(scope="module")
def setup_database():
    """Set up database session for e2e tests."""
    # Initialize database session for testing
    init_database_session(app)
    
    # Provide database session to tests
    SessionLocal = app.state.db_session_factory
    db = SessionLocal()
    try:
        yield db  # Provide the database session to tests
    finally:
        db.close()


@pytest.mark.e2e
def test_click_button_displays_test_ping(page: Page):
    # Open the frontend app
    page.goto(LOCAL_HOST_URL)

    # Navigate to the Main tab (should be default, but ensure we're on the right tab)
    page.get_by_test_id("main-nav-button").click()
    
    # Wait for the main content to be visible
    main_content = page.get_by_test_id("main-content")
    expect(main_content).to_be_visible()

    # Click the button labeled "Click me"
    page.get_by_role("button", name="Click me").click()

    # Expect the TEST_PING text to become visible
    expect(page.get_by_text(TEST_PING)).to_be_visible()

    # Additionally, verify that the TEST_PING text is displayed to the right of the button
    button = page.get_by_role("button", name="Click me")
    resp_text = page.get_by_text(TEST_PING)

    # Get bounding boxes for both elements
    button_box = button.bounding_box()
    resp_box = resp_text.bounding_box()

    # Assert that the TEST_PING text is to the right of the button
    assert button_box is not None and resp_box is not None, "Could not get bounding boxes"
    assert resp_box["x"] > button_box["x"] + button_box["width"], "TEST_PING text is not to the right of the button"
    
    # Also verify they are on the same vertical position
    button_center_y = button_box["y"] + button_box["height"] / 2
    resp_center_y = resp_box["y"] + resp_box["height"] / 2
    assert abs(button_center_y - resp_center_y) < 5, "TEST_PING text is not aligned vertically with the button"


@pytest.mark.e2e
def test_click_show_me_a_user_button_displays_user_info(page: Page):
    # Open the frontend app
    page.goto(LOCAL_HOST_URL)

    # Navigate to the Users tab first
    page.get_by_test_id("users-nav-button").click()
    
    # Wait for the users content to be visible
    users_content = page.get_by_test_id("users-content")
    expect(users_content).to_be_visible()

    # Click the button labeled "Show me a user"
    page.get_by_role("button", name="Show me a user").click()

    # Wait for the user information to be displayed in the specific user display area
    # Use the new data-testid for more reliable targeting
    user_display_area = page.get_by_test_id("user-display-content")
    expect(user_display_area).to_be_visible()
    
    # Verify that the user information is displayed in the correct container
    # Check for the specific user data labels within the user display area
    expect(user_display_area.get_by_text("Name:")).to_be_visible()
    expect(user_display_area.get_by_text("Gender:")).to_be_visible()
    expect(user_display_area.get_by_text("Age:")).to_be_visible()

    # Verify that the user information is displayed in the correct format
    # The text should be in the format: "Name: [name]", "Gender: [gender]", "Age: [age]"
    user_info_container = user_display_area.locator("div:has-text('Name:')").first
    expect(user_info_container).to_be_visible()
    
    # Verify that the "No user selected yet." text is no longer visible
    expect(page.get_by_text("No user selected yet.")).not_to_be_visible()


@pytest.mark.e2e
def test_click_add_user_button(page: Page, setup_database: Session):
    """
    Use FakeUser to test the add user button.
    """

    # Open the frontend app
    page.goto(LOCAL_HOST_URL)
    
    # Navigate to the Users tab
    page.get_by_test_id("users-nav-button").click()
    
    # Wait for the users content to be visible
    users_content = page.get_by_test_id("users-content")
    expect(users_content).to_be_visible()
    
    # Locate the add-user-form div by its data-testid
    add_user_form = page.get_by_test_id("add-user-form")

    # Fill the form fields using data from FakeUser
    add_user_form.get_by_label("Name").fill(FakeUser["name"])
    add_user_form.get_by_label("Gender").select_option(FakeUser["gender"])
    add_user_form.get_by_label("Age").fill(str(FakeUser["age"]))

    # Click the "Add User" button within the form
    add_user_form.get_by_role("button", name="Add User").click()
    
    # Wait for the popup modal to appear using the friendly ID
    popup_modal = page.get_by_test_id("add-user-popup-modal")
    expect(popup_modal).to_be_visible()
    
    # Verify the popup content is visible using the friendly ID
    popup_content = page.get_by_test_id("add-user-popup-content")
    expect(popup_content).to_be_visible()
    
    # Locate the popup message by its ID and check for the success message within it
    popup_message = popup_content.get_by_test_id("add-user-popup-message")
    expect(popup_message).to_contain_text(USER_ADD_RESULT["success"].message)
    
    # Verify the OK button is present and clickable
    ok_button = popup_content.get_by_role("button", name="OK")
    expect(ok_button).to_be_visible()
    expect(ok_button).to_be_enabled()
    
    # Clean up: delete the fake user after test completion
    try:
        delete_fake_user(setup_database)
    except Exception as e:
        print(f"Failed to delete fake user: {e}")
```

To run the tests, use the following command:
>#to test fastapi:
>
>pytest -v -m fastapi

>#to test e2e (need to start backend server first):
>
>#install dependencies for playwright, only need to run once:
>
>playwright install
>
>#then start e2e test:
>
>pytest -v -m e2e

>#to run all tests:
>
>pytest -v